AGPM漏洞，通过客户端进行通信
      case 7317:
        v7 = (AGPM *)a1[27];
        if ( !v7 )
          goto LABEL_86;
        result = __stack_chk_guard;
        if ( __stack_chk_guard == v18 )
          result = AGPM::clearPstatesOccupancy(v7);
        return result;
      case 7318:
        result = __stack_chk_guard;
        if ( __stack_chk_guard == v18 )
          result = AGPMClient::getPstatesOccupancy((__int64)a1, a3);
        return result;
17清空
18读取


__int64 __fastcall AGPMClient::getPstatesOccupancy(__int64 a1, __int64 a2)
{
  __int64 v2; // r14
  __int64 v3; // rbx
  AGPM *v4; // rdi
  __int64 result; // rax
  unsigned int v6; // esi
  unsigned __int64 *v7; // rcx
  unsigned __int64 v8; // [rsp+8h] [rbp-38h]
  unsigned __int64 v9; // [rsp+10h] [rbp-30h]
  unsigned __int64 v10; // [rsp+18h] [rbp-28h]
  unsigned __int64 v11; // [rsp+20h] [rbp-20h]
  unsigned int v12; // [rsp+2Ch] [rbp-14h]

  v2 = a2;
  v3 = a1;
  v4 = *(AGPM **)(a1 + 216);
  if ( !v4 )
    return 3758097113LL;
  result = AGPM::getMaxPowerState(v4, &v12);//这里现在限制大小了
  if ( !(_DWORD)result )
  {
    v6 = **(_DWORD **)(a2 + 0x20);//scalarinputcount
    result = 3758097090LL;
    if ( v6 <= v12 )
    {
      result = AGPM::getPstatesOccupancy(*(AGPM **)(v3 + 216), v6, &v8, &v9, &v10, &v11);
      if ( !(_DWORD)result )
      {
        v7 = *(unsigned __int64 **)(v2 + 0x48);//scalaroutputcount
        *v7 = v8;
        v7[1] = v9;
        v7[2] = v10;
        v7[3] = v11;
        result = 0LL;
      }
    }
  }
  return result;
}