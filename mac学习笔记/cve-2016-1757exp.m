# execve 切换引起的漏洞


## execve程序流程
__mac_execve
    ->
        exec_activate_image()
            ->
                exec_mach_imgact()
                    ->
                        load_machfile
                            ->parse_machfile
                                -> load_dylinker()
                                    return dyld
                                    
```
int
__mac_execve(proc_t p, struct __mac_execve_args *uap, int32_t *retval)
{
    char *bufp = NULL; 
    struct image_params *imgp;
    struct vnode_attr *vap;
    struct vnode_attr *origvap;
    int error;
    int is_64 = IS_64BIT_PROCESS(p);
    struct vfs_context context;
    struct uthread    *uthread;
    
      //初始化context
    context.vc_thread = current_thread();
    context.vc_ucred = kauth_cred_proc_ref(p);    /* XXX must NOT be kauth_cred_get() */

    /* Allocate a big chunk for locals instead of using stack since these  
     * structures a pretty big.
     */
      //申请一块连续的大内存，用来存放imgp，vap，origvap的数据结构
    MALLOC(bufp, char *, (sizeof(*imgp) + sizeof(*vap) + sizeof(*origvap)), M_TEMP, M_WAITOK | M_ZERO);
    imgp = (struct image_params *) bufp;
    if (bufp == NULL) {
        error = ENOMEM
        goto exit_with_error;
    }
      //通过数据结构size的偏移，指向对应的内存空间
      //imgp,vap,origvap实际是连续的一块内存
    vap = (struct vnode_attr *) (bufp + sizeof(*imgp));
    origvap = (struct vnode_attr *) (bufp + sizeof(*imgp) + sizeof(*vap));
    
    /* Initialize the common data in the image_params structure */
    //初始化数据
      imgp->ip_user_fname = uap->fname;
    imgp->ip_user_argv = uap->argp;
    imgp->ip_user_envv = uap->envp;
    imgp->ip_vattr = vap;
    imgp->ip_origvattr = origvap;
    imgp->ip_vfs_context = &context;
    imgp->ip_flags = (is_64 ? IMGPF_WAS_64BIT : IMGPF_NONE) | ((p->p_flag & P_DISABLE_ASLR) ? IMGPF_DISABLE_ASLR : IMGPF_NONE);
    imgp->ip_seg = (is_64 ? UIO_USERSPACE64 : UIO_USERSPACE32);
    imgp->ip_mac_return = 0;

      //设置线程信息
    uthread = get_bsdthread_info(current_thread());
    if (uthread->uu_flag & UT_VFORK) {
        imgp->ip_flags |= IMGPF_VFORK_EXEC;
    }

      //MAC模块相应的处理，与进程的权限相关
      //MAC:https://www.freebsd.org/doc/handbook/mac.html
#if CONFIG_MACF
    if (uap->mac_p != USER_ADDR_NULL) {
        error = mac_execve_enter(uap->mac_p, imgp);
        if (error) {
            kauth_cred_unref(&context.vc_ucred);
            goto exit_with_error;
        }
    }
#endif
    
      //执行image
    error = exec_activate_image(imgp);

      //释放资源与出错处理
    kauth_cred_unref(&context.vc_ucred);
    
    /* Image not claimed by any activator? */
    if (error == -1)
        error = ENOEXEC;
    /*...*/    
    return(error);
}
```

初始化后进入 exec_activate
```
/*
 * exec_activate_image
 *
 * Description:    Iterate through the available image activators, and activate
 *        the image associated with the imgp structure.  We start with
 *        the
 *
 * Parameters:    struct image_params *    Image parameter block
 *
 * Returns:    0            Success
 *        EBADEXEC        The executable is corrupt/unknown
 *    execargs_alloc:EINVAL        Invalid argument
 *    execargs_alloc:EACCES        Permission denied
 *    execargs_alloc:EINTR        Interrupted function
 *    execargs_alloc:ENOMEM        Not enough space
 *    exec_save_path:EFAULT        Bad address
 *    exec_save_path:ENAMETOOLONG    Filename too long
 *    exec_check_permissions:EACCES    Permission denied
 *    exec_check_permissions:ENOEXEC    Executable file format error
 *    exec_check_permissions:ETXTBSY    Text file busy [misuse of error code]
 *    exec_check_permissions:???
 *    namei:???
 *    vn_rdwr:???            [anything vn_rdwr can return]
 *    <ex_imgact>:???            [anything an imgact can return]
 */
static int
exec_activate_image(struct image_params *imgp)
{
    struct nameidata *ndp = NULL;
    const char *excpath;
    int error;
    int resid;
    int once = 1;    /* save SGUID-ness for interpreted files */
    int i;
    int itercount = 0;
    proc_t p = vfs_context_proc(imgp->ip_vfs_context);

    error = execargs_alloc(imgp);
    if (error)
        goto bad_notrans;
    
    error = exec_save_path(imgp, imgp->ip_user_fname, imgp->ip_seg, &excpath);
    if (error) {
        goto bad_notrans;
    }

    /* Use excpath, which contains the copyin-ed exec path */
    DTRACE_PROC1(exec, uintptr_t, excpath);

    MALLOC(ndp, struct nameidata *, sizeof(*ndp), M_TEMP, M_WAITOK | M_ZERO);
    if (ndp == NULL) {
        error = ENOMEM;
        goto bad_notrans;
    }

    NDINIT(ndp, LOOKUP, OP_LOOKUP, FOLLOW | LOCKLEAF | AUDITVNPATH1,
           UIO_SYSSPACE, CAST_USER_ADDR_T(excpath), imgp->ip_vfs_context);

again:
    error = namei(ndp); //todo:    详细流程先不看，研究下来感觉是路径的搜索
    if (error)
        goto bad_notrans;
    imgp->ip_ndp = ndp;    /* successful namei(); call nameidone() later */
    imgp->ip_vp = ndp->ni_vp;    /* if set, need to vnode_put() at some point */

    /*
     * Before we start the transition from binary A to binary B, make
     * sure another thread hasn't started exiting the process.  We grab
     * the proc lock to check p_lflag initially, and the transition
     * mechanism ensures that the value doesn't change after we release
     * the lock.
     */
    proc_lock(p);
    if (p->p_lflag & P_LEXIT) {
        proc_unlock(p);
        goto bad_notrans;
    }
    error = proc_transstart(p, 1, 0);
    proc_unlock(p);
    if (error)
        goto bad_notrans;

    error = exec_check_permissions(imgp);
    if (error)
        goto bad;

    /* Copy; avoid invocation of an interpreter overwriting the original */
    if (once) {
        once = 0;
        *imgp->ip_origvattr = *imgp->ip_vattr;
    }
    //读取数据到内存中
    error = vn_rdwr(UIO_READ, imgp->ip_vp, imgp->ip_vdata, PAGE_SIZE, 0,
            UIO_SYSSPACE, IO_NODELOCKED,
            vfs_context_ucred(imgp->ip_vfs_context),
            &resid, vfs_context_proc(imgp->ip_vfs_context));
    if (error)
        goto bad;

    if (resid) {
        memset(imgp->ip_vdata + (PAGE_SIZE - resid), 0x0, resid);
    }

      //到这里之前的代码主要做了两件事情
      //1.根据路径查找文件
      //2.将文件拷贝到内存中
encapsulated_binary:
    /* Limit the number of iterations we will attempt on each binary */
    if (++itercount > EAI_ITERLIMIT) {
        error = EBADEXEC;
        goto bad;
    }
    error = -1;
    for(i = 0; error == -1 && execsw[i].ex_imgact != NULL; i++) {
        //这里对macho文件进行了解析
        error = (*execsw[i].ex_imgact)(imgp);    //todo:调用了一个指针函数，exec_mach_imgact
          //总共有三种函数
          /*
        struct execsw {
        int (*ex_imgact)(struct image_params *);
        const char *ex_name;
        } execsw[] = {
        { exec_mach_imgact,        "Mach-o Binary" },
        { exec_fat_imgact,        "Fat Binary" },
        { exec_shell_imgact,        "Interpreter Script" },
        { NULL, NULL}
};
*/
          //分别是osx支持的三种不同的可执行文件

        switch (error) {
            /*出错处理*/
        }
    }

    /*
     * Call out to allow 3rd party notification of exec. 
     * Ignore result of kauth_authorize_fileop call.
     */
    if (error == 0 && kauth_authorize_fileop_has_listeners()) {
        kauth_authorize_fileop(vfs_context_ucred(imgp->ip_vfs_context),
                    KAUTH_FILEOP_EXEC,
                    (uintptr_t)ndp->ni_vp, 0);
    }

bad:
    proc_transend(p, 0);

bad_notrans:
    if (imgp->ip_strings)
        execargs_free(imgp);
    if (imgp->ip_ndp)
        nameidone(imgp->ip_ndp);
    if (ndp)
        FREE(ndp, M_TEMP);

    return (error);
}
```

这个函数主要做的事情就是寻找并拷贝可执行文件到内存中，并且根据可执行文件的类型调用不同的解析函数。osx总共支持三种可执行文件。他们各自有对应的处理函数。

exec_mach_imgact太长了不贴了
该函数主要做这几件事情：

    1对macho文件做最基本的检测
    2fork新的线程运行macho
    3映射macho文件到内存中
    4对setuid，code-sign等权限相关的事情有处理
    5为dyld接手macho文件的处理做了大量的准备工作
    6dyld处理完之后，对资源的释放
    
在load_machfile里面进行了安全设置。




```

oad_return_t
load_machfile(
    struct image_params    *imgp,
    struct mach_header    *header,
    thread_t         thread,
    vm_map_t         new_map,
    load_result_t        *result
)
{
    struct vnode        *vp = imgp->ip_vp;
    off_t            file_offset = imgp->ip_arch_offset;
    off_t            macho_size = imgp->ip_arch_size;
    off_t            file_size = imgp->ip_vattr->va_data_size;
    
    pmap_t            pmap = 0;    /* protected by create_map */
    vm_map_t        map;
    vm_map_t        old_map;
    task_t            old_task = TASK_NULL; /* protected by create_map */
    load_result_t        myresult;
    load_return_t        lret;
    boolean_t create_map = FALSE;
    boolean_t enforce_hard_pagezero = TRUE;
    int spawn = (imgp->ip_flags & IMGPF_SPAWN);
    task_t task = current_task();
    proc_t p = current_proc();
    mach_vm_offset_t    aslr_offset = 0;
    mach_vm_offset_t    dyld_aslr_offset = 0;
    kern_return_t         kret;

    if (macho_size > file_size) {
        return(LOAD_BADMACHO);
    }

    if (new_map == VM_MAP_NULL) {
        create_map = TRUE;
        old_task = current_task();
    }

    /*
     * If we are spawning, we have created backing objects for the process
     * already, which include non-lazily creating the task map.  So we
     * are going to switch out the task map with one appropriate for the
     * bitness of the image being loaded.
     */
    if (spawn) {
        create_map = TRUE;
        old_task = get_threadtask(thread);
    }
    
      //如果有new_map就用参数传进来的new_map
      //否则就通过pmap_create,vm_map_create函数创建新的内存空间
    if (create_map) {
        task_t ledger_task;
        if (imgp->ip_new_thread) {
            ledger_task = get_threadtask(imgp->ip_new_thread);
        } else {
            ledger_task = task;
        }
        pmap = pmap_create(get_task_ledger(ledger_task),
                   (vm_map_size_t) 0,
                   ((imgp->ip_flags & IMGPF_IS_64BIT) != 0));
        pal_switch_pmap(thread, pmap, imgp->ip_flags & IMGPF_IS_64BIT);
        map = vm_map_create(pmap,
                0,
                vm_compute_max_offset(((imgp->ip_flags & IMGPF_IS_64BIT) == IMGPF_IS_64BIT)),
                TRUE);
    } else
        map = new_map;

#if   (__ARM_ARCH_7K__ >= 2) && defined(PLATFORM_WatchOS)
    /* enforce 16KB alignment for watch targets with new ABI */
    vm_map_set_page_shift(map, SIXTEENK_PAGE_SHIFT);
#endif /* __arm64__ */

#ifndef    CONFIG_ENFORCE_SIGNED_CODE
    /* This turns off faulting for executable pages, which allows
     * to circumvent Code Signing Enforcement. The per process
     * flag (CS_ENFORCEMENT) is not set yet, but we can use the
     * global flag.
     */
    if ( !cs_enforcement(NULL) && (header->flags & MH_ALLOW_STACK_EXECUTION) )
            vm_map_disable_NX(map);
#endif

    /* Forcibly disallow execution from data pages on even if the arch
     * normally permits it. */
      //将内存设置为不可执行，用来防止溢出漏洞的利用
    if ((header->flags & MH_NO_HEAP_EXECUTION) && !(imgp->ip_flags & IMGPF_ALLOW_DATA_EXEC))
        vm_map_disallow_data_exec(map);
    
    /*
     * Compute a random offset for ASLR, and an independent random offset for dyld.
     */
      //地址随机，计算ASLR的偏移量
    if (!(imgp->ip_flags & IMGPF_DISABLE_ASLR)) {
        uint64_t max_slide_pages;

        max_slide_pages = vm_map_get_max_aslr_slide_pages(map);

        aslr_offset = random();
        aslr_offset %= max_slide_pages;
        aslr_offset <<= vm_map_page_shift(map);

        dyld_aslr_offset = random();
        dyld_aslr_offset %= max_slide_pages;
        dyld_aslr_offset <<= vm_map_page_shift(map);
    }
    
    if (!result)
        result = &myresult;

    *result = load_result_null;

      //解析macho的文件格式
    lret = parse_machfile(vp, map, thread, header, file_offset, macho_size,
                          0, (int64_t)aslr_offset, (int64_t)dyld_aslr_offset, result);

    if (lret != LOAD_SUCCESS) {
        if (create_map) {
            vm_map_deallocate(map);    /* will lose pmap reference too */
        }
        return(lret);
    }

#if __x86_64__
    /*
     * On x86, for compatibility, don't enforce the hard page-zero restriction for 32-bit binaries.
     */
    if ((imgp->ip_flags & IMGPF_IS_64BIT) == 0) {
        enforce_hard_pagezero = FALSE;
    }
#endif
    /*
     * Check to see if the page zero is enforced by the map->min_offset.
     */ 
    if (enforce_hard_pagezero &&
        (vm_map_has_hard_pagezero(map, 0x1000) == FALSE)) {
        {
            if (create_map) {
                vm_map_deallocate(map);    /* will lose pmap reference too */
            }
            return (LOAD_BADMACHO);
        }
    }

    /*
     *    Commit to new map.
     *
     *    Swap the new map for the old, which  consumes our new map
     *    reference but each leaves us responsible for the old_map reference.
     *    That lets us get off the pmap associated with it, and
     *    then we can release it.
     */
     //用新申请的内存替换原来的内存
     if (create_map) {
        /*
         * If this is an exec, then we are going to destroy the old
         * task, and it's correct to halt it; if it's spawn, the
         * task is not yet running, and it makes no sense.
         */
         if (!spawn) {
            /*
             * Mark the task as halting and start the other
             * threads towards terminating themselves.  Then
             * make sure any threads waiting for a process
             * transition get informed that we are committed to
             * this transition, and then finally complete the
             * task halting (wait for threads and then cleanup
             * task resources).
             *
             * NOTE: task_start_halt() makes sure that no new
             * threads are created in the task during the transition.
             * We need to mark the workqueue as exiting before we
             * wait for threads to terminate (at the end of which
             * we no longer have a prohibition on thread creation).
             * 
             * Finally, clean up any lingering workqueue data structures
             * that may have been left behind by the workqueue threads
             * as they exited (and then clean up the work queue itself).
             */
            kret = task_start_halt(task);
            if (kret != KERN_SUCCESS) {
                vm_map_deallocate(map);    /* will lose pmap reference too */
                return (LOAD_FAILURE);
            }
            proc_transcommit(p, 0);
            workqueue_mark_exiting(p);
            task_complete_halt(task);
            workqueue_exit(p);
            kqueue_dealloc(p->p_wqkqueue);
            p->p_wqkqueue = NULL;
        }
        old_map = swap_task_map(old_task, thread, map, !spawn);
        vm_map_deallocate(old_map);
    }
    return(LOAD_SUCCESS);
}
```
可以看到，将新内存替换完旧内存才会销毁旧的端口（在上层函数里面），在此之间更改新内存，从而l修改代码。




refer
http://turingh.github.io/2016/07/05/%E5%86%8D%E7%9C%8BCVE-2016-1757%E6%B5%85%E6%9E%90mach%20message%E7%9A%84%E4%BD%BF%E7%94%A8/
