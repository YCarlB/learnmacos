# task_swap_mach_voucher 绕过pac验证
## 漏洞发现
首先，漏洞依旧是在MIG模块下面。
    
可以看到
https://github.com/apple/darwin-xnu/blob/a449c6a3b8014d9406c2ddbdc81795da24aa7443/osfmk/kern/sync_sema.c
```
    task = convert_port_to_task(In0P->Head.msgh_request_port);

    OutP->RetCode = semaphore_destroy(task,
            convert_port_to_semaphore(In0P->semaphore.name));
    task_deallocate(task);
#if __MigKernelSpecificCode
    if (OutP->RetCode != KERN_SUCCESS) {
        MIG_RETURN_ERROR(OutP, OutP->RetCode);
    }


    if (IP_VALID((ipc_port_t)In0P->semaphore.name))
        ipc_port_release_send((ipc_port_t)In0P->semaphore.name);
#endif /* __MigKernelSpecificCode */
```

这个函数中添加了一个引用和一个权限，然而只删除了权限，semaphore_destory里面需要销毁引用。
```
semaphore_destroy(
    task_t            task,
    semaphore_t        semaphore)
{
    spl_t spl_level;

    if (semaphore == SEMAPHORE_NULL)
        return KERN_INVALID_ARGUMENT;

    if (task == TASK_NULL) { //这里原来没有
        semaphore_dereference(semaphore);
        return KERN_INVALID_ARGUMENT;
    }

    task_lock(task);
    spl_level = splsched();
    semaphore_lock(semaphore);

    if (semaphore->owner != task) {
        semaphore_unlock(semaphore);
        semaphore_dereference(semaphore);
        splx(spl_level);
        task_unlock(task);
        return KERN_INVALID_ARGUMENT;
    }

    semaphore_destroy_internal(task, semaphore);
    /* semaphore unlocked */

    splx(spl_level);
    task_unlock(task);

    semaphore_dereference(semaphore);
    return KERN_SUCCESS;
}
```
新版函数中添加了释放，但是原来缺少一个释放。

然后查看他的defs可以看到其他函数，然后在同一个目录下的另一个文件中的函数。

https://github.com/apple/darwin-xnu/blob/a449c6a3b8014d9406c2ddbdc81795da24aa7443/osfmk/kern/task.c

存在漏洞

## 漏洞分析


    ```
    task_swap_mach_voucher(
    task_t            task,
    ipc_voucher_t        new_voucher,
    ipc_voucher_t        *in_out_old_voucher)
    {
    if (TASK_NULL == task)
        return KERN_INVALID_TASK;

    *in_out_old_voucher = new_voucher;
    return KERN_SUCCESS;
    }
    ```
    这个结合MIG的server看
    
```

mig_internal novalue _Xtask_swap_mach_voucher
       (mach_msg_header_t *InHeadP, mach_msg_header_t *OutHeadP)
{
...
   kern_return_t RetCode;
   task_t task;
   ipc_voucher_t new_voucher;
   ipc_voucher_t old_voucher;
...
   task = convert_port_to_task(In0P->Head.msgh_request_port);

   new_voucher = convert_port_to_voucher(In0P->new_voucher.name);

   old_voucher = convert_port_to_voucher(In0P->old_voucher.name);

   RetCode = task_swap_mach_voucher(task, new_voucher, &old_voucher);

   ipc_voucher_release(new_voucher);//释放一次

   task_deallocate(task);

   if (RetCode != KERN_SUCCESS) {
       MIG_RETURN_ERROR(OutP, RetCode);
   }
...
   if (IP_VALID((ipc_port_t)In0P->old_voucher.name))
       ipc_port_release_send((ipc_port_t)In0P->old_voucher.name);

   if (IP_VALID((ipc_port_t)In0P->new_voucher.name))
       ipc_port_release_send((ipc_port_t)In0P->new_voucher.name);


...
   OutP->old_voucher.name = (mach_port_t)convert_voucher_to_port(old_voucher);//释放第二次

   OutP->Head.msgh_bits |= MACH_MSGH_BITS_COMPLEX;
   OutP->Head.msgh_size = (mach_msg_size_t)(sizeof(Reply));
   OutP->msgh_body.msgh_descriptor_count = 1;
}

```
可以看到通过函数调用后，两次释放的全是一个port，从而造成doublefree。

##漏洞利用 

通过double free 让内存被释放到zone里，通过gc回收到我们可控的区域，然后通过fake_port来进行利用


让recviveport在voucherport附近，然后修改voucherport指针地址为recviveport地址，这样用户就可以读取内容了。


将voucherport伪造为osstring的内存
然后通过pid_for_task和d可读端口来进行任意地址读

通过remap可以把内核地址与用户地址映射，从而避免每次都要去内核修改。






#### refer 
http://blogs.360.cn/post/IPC%20Voucher%20UaF%20Remote%20Jailbreak%20Stage%202.html


https://googleprojectzero.blogspot.com/2019/01/voucherswap-exploiting-mig-reference.html
