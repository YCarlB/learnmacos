# mtcp漏洞
## mtcp 漏洞分析

```
f (src) {
    // verify sa_len for AF_INET
        if (src->sa_family == AF_INET &&
            src->sa_len != sizeof(mpte->__mpte_src_v4)) {
            mptcplog((LOG_ERR, "%s IPv4 src len %u\n", __func__,
                  src->sa_len),
                 MPTCP_SOCKET_DBG, MPTCP_LOGLVL_ERR);
            error = EINVAL;
            goto out;
        }
    // verify sa_len for AF_INET6
        if (src->sa_family == AF_INET6 &&
            src->sa_len != sizeof(mpte->__mpte_src_v6)) {
            mptcplog((LOG_ERR, "%s IPv6 src len %u\n", __func__,
                  src->sa_len),
                 MPTCP_SOCKET_DBG, MPTCP_LOGLVL_ERR);
            error = EINVAL;
            goto out;
        }
    // code doesn't bail if sa_family is neither AF_INET nor AF_INET6
        if ((mp_so->so_state & (SS_ISCONNECTED|SS_ISCONNECTING)) == 0) {
            memcpy(&mpte->mpte_src, src, src->sa_len);
        }
    }

```
首先这个漏洞在第三种情况，既不是4也不是6的情况下会不检查长度，直接发生复制，从而造成溢出。

## 漏洞利用

    首先mtcp结构体下面有个指向kmsg的结构
    我们申请大量msg结构，然后通过修改指针来对msg进行释放，
    之后我们申请pipe来占据我们释放的内存
    然后我们再次利用漏洞，释放pipe
    再次申请kmsg来进行信息泄漏
    最后通过更改pipe来进行让kmsg的端口指向fakeport进行利用。

    具体流程见exp的中文注释
